\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{graphicx,listings}
\usepackage{tabularx}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs} 
\usepackage{textgreek}

\title{INFO403 – Part 2: Syntactic Analysis of yaLcc\\
\large LL(1) Grammar Transformation and Parser Implementation}
\author{Zakaria M'Hamdi (000630126) \& Wassim Turk (000630128)}
\date{November 2025}

\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  columns=flexible,
  keepspaces=true,
  breaklines=true,
}

\begin{document}

\maketitle

\begin{abstract}
This report presents the transformation of the yaLcc grammar and the implementation 
of an LL(1) parser. Following the lexical analysis phase of Part~1, this work focuses on grammar 
refinement, removal of ambiguities, and structural adjustments (elimination of left recursion and 
factorization) to ensure deterministic parsing. The resulting grammar forms the foundation for the implementation of the parser that interprets yaLcc source programs. 
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

In the compilation process, \textbf{syntactic analysis} (or \textit{parsing}) follows lexical analysis.
Its goal is to verify whether a sequence of tokens generated by the scanner matches with 
syntactic rules of the language.

A \textbf{parser} is the compiler component responsible for this task.
It takes as input the sequence of tokens produced by the lexical analyzer and checks whether
it matches the language grammar. If so, it produces a hierarchical structure called a
\textit{parse tree} (or derivation tree), which represents the syntactic relationships between
the elements of the program.

In this project, we design a deterministic \textbf{LL(1) recursive descent parser} for the
\textit{yaLcc} language. The term LL(1) stands for:
\begin{itemize}
  \item \textbf{L}eft-to-right reading of the input,
  \item \textbf{L}eftmost derivation construction,
  \item and \textbf{1} lookahead token to decide which production rule to apply.
\end{itemize}
LL(1) grammars are non-ambiguous, non-left-recursive, and can be parsed deterministically
without backtracking. They are therefore well-suited for top-down parsing implementations,
where each non-terminal is mapped to a corresponding parsing function in code.



\section{Objectives of Part 2}
The main objective of this part is to construct the \textbf{syntactic analyzer (parser)} for the 
yaLcc language. To do so, we must:
\begin{enumerate}
  \item Transform the original yaLcc grammar to a LL(1) grammar :
  \begin{itemize}
    \item By removing unproductive or unreachable non-terminals (if any);
    \item By Resolving ambiguities by encoding operator \textbf{precedence} and \textbf{associativity};
    \item By Eliminating left recursion and apply factorization where necessary.
  \end{itemize}
  \item Verify that the final grammar is LL(1) by computing its \textbf{FIRST} and \textbf{FOLLOW} sets.
  \item Construct the LL(1) action table and justify it.
  \item Finally, implement a recursive descent parser in Java.
\end{enumerate}


\section{Original Grammar of yaLcc}
Before any modification, we start from the original grammar provided in the project.
This grammar defines the full syntax of yaLcc before any transformation. Each rule is numbered
as in Table~1 of the assignment:

\begin{table}[H]
\centering
\small
\begin{tabular}{r l l}
[1]  & $\langle Program \rangle$    & $\rightarrow$ Prog [ProgName] Is $\langle Code \rangle$ End \\[2pt]
[2]  & $\langle Code \rangle$       & $\rightarrow$ $\langle Instruction \rangle$ ; $\langle Code \rangle$ \\[2pt]
[3]  &                              & $\rightarrow$ $\varepsilon$ \\[2pt]
[4]  & $\langle Instruction \rangle$& $\rightarrow$ $\langle Assign \rangle$ \\[2pt]
[5]  &                              & $\rightarrow$ $\langle If \rangle$ \\[2pt]
[6]  &                              & $\rightarrow$ $\langle While \rangle$ \\[2pt]
[7]  &                              & $\rightarrow$ $\langle Call \rangle$ \\[2pt]
[8]  &                              & $\rightarrow$ $\langle Output \rangle$ \\[2pt]
[9]  &                              & $\rightarrow$ $\langle Input \rangle$ \\[2pt]
[10] & $\langle Assign \rangle$     & $\rightarrow$ [VarName] = $\langle ExprArith \rangle$ \\[2pt]
[11] & $\langle ExprArith \rangle$  & $\rightarrow$ [VarName] \\[2pt]
[12] &                              & $\rightarrow$ [Number] \\[2pt]
[13] &                              & $\rightarrow$ ( $\langle ExprArith \rangle$ ) \\[2pt]
[14] &                              & $\rightarrow$ - $\langle ExprArith \rangle$ \\[2pt]
[15] &                              & $\rightarrow$ $\langle ExprArith \rangle$ $\langle Op \rangle$ $\langle ExprArith \rangle$ \\[2pt]
[16] & $\langle Op \rangle$         & $\rightarrow$ + \\[2pt]
[17] &                              & $\rightarrow$ - \\[2pt]
[18] &                              & $\rightarrow$ * \\[2pt]
[19] &                              & $\rightarrow$ / \\[2pt]
[20] & $\langle If \rangle$         & $\rightarrow$ If { $\langle Cond \rangle$ } Then $\langle Code \rangle$ End 
                                     \hspace{1cm}\\[2pt]
[21] &                              & $\rightarrow$ If { $\langle Cond \rangle$ } Then $\langle Code \rangle$ Else $\langle Code \rangle$ End \\[2pt]
[22] & $\langle Cond \rangle$       & $\rightarrow$ $\langle Cond \rangle$ \texttt{->} $\langle Cond \rangle$ \\[2pt]
[23] &                              & $\rightarrow$ \texttt{|}$\langle Cond \rangle$\texttt{|} \\[2pt]
[24] &                              & $\rightarrow$ $\langle ExprArith \rangle$ $\langle Comp \rangle$ $\langle ExprArith \rangle$ \\[2pt]
[25] & $\langle Comp \rangle$       & $\rightarrow$ == \\[2pt]
[26] &                              & $\rightarrow$ \texttt{<=} \\[2pt]
[27] &                              & $\rightarrow$ \texttt{<} \\[2pt]
[28] & $\langle While \rangle$      & $\rightarrow$ While { $\langle Cond \rangle$ } Do $\langle Code \rangle$ End \\[2pt]
[29] & $\langle Output \rangle$     & $\rightarrow$ Print([VarName]) \\[2pt]
[30] & $\langle Input \rangle$      & $\rightarrow$ Input([VarName]) \\
\end{tabular}
\caption{The yaLcc original grammar.}
\end{table}


Before implementing an LL(1) parser, the grammar must first be transformed to ensure that it can be
parsed deterministically. The transformations required in steps (a), (b), and (c) have specific objectives:

\begin{itemize}
  \item \textbf{Step (a)} --- Removing unproductive and unreachable variables ensures that every
  non-terminal in the grammar can eventually produce a valid sequence of terminals and that all
  rules are accessible from the start symbol. This guarantees that the grammar defines only
  meaningful and reachable constructs.

  \item \textbf{Step (b)} --- Resolving ambiguities by defining operator precedence and associativity
  eliminates multiple possible parse trees for the same expression. This is essential to make the
  grammar deterministic and to ensure that the parser can always select one unique production
  for each input.

  \item \textbf{Step (c)} --- Removing left recursion and applying left factoring are mandatory
  transformations for top-down parsing. Left recursion causes infinite recursion in recursive descent
  parsers, while common prefixes between productions make prediction impossible.
  Eliminating them guarantees that the grammar can be parsed using a single lookahead token,
  as required by the LL(1) property.
\end{itemize}

Together, these transformations make the grammar suitable for predictive parsing and are a
prerequisite for constructing the LL(1) action table and implementing the recursive descent parser.

\section{Grammar Transformation Steps}

\subsection{(a) Removing Unproductive and Unreachable Variables}

The original grammar (Table~1) contains a non-terminal \texttt{<Call>} referenced by
\texttt{<Instruction>} but with no production rule defining it. Hence, \texttt{<Call>} is
non-productive. We therefore removed the alternative \texttt{<Call>} from \texttt{<Instruction>}.
All remaining non-terminals are productive and reachable from \texttt{<Program>}.

Removing such a symbol is essential for obtaining a consistent grammar. A non-productive
non-terminal could never generate a valid terminal string and would lead the parser into
dead ends during derivation. Eliminating \texttt{<Call>} ensures that every production is
reachable and that the grammar forms a correct basis for LL(1) transformation.


\subsection{(b) Resolving Ambiguity: Operator Precedence and Associativity}

The original grammar contained ambiguous constructs for arithmetic and boolean 
expressions. In particular, the rule:
\[
\langle ExprArith \rangle \to \langle ExprArith \rangle \; \langle Op \rangle \; \langle ExprArith \rangle
\]
does not encode operator precedence or associativity. An expression such as 
\texttt{a - b - c} may be parsed either as \texttt{(a - b) - c} or \texttt{a - (b - c)}, 
producing ambiguity and preventing deterministic parsing.

To eliminate ambiguity, we introduced a layered structure for arithmetic expressions,
following the precedence and associativity rules specified in the project:

\begin{itemize}
    \item \texttt{*} and \texttt{/} have higher precedence than \texttt{+} and \texttt{-}.
    \item All binary arithmetic operators are left-associative.
    \item Unary minus has the highest precedence and is right-associative.
\end{itemize}

This leads to the following hierarchy:
\[
\begin{array}{rcl}
\langle ExprArith \rangle 
    & \to & \langle Prod \rangle \;\langle ExprArith' \rangle \\[6pt]

\langle ExprArith' \rangle 
    & \to & +\;\langle Prod \rangle \;\langle ExprArith' \rangle 
            \;\;|\;\; -\;\langle Prod \rangle \;\langle ExprArith' \rangle 
            \;\;|\;\; \epsilon \\[6pt]

\langle Prod \rangle 
    & \to & \langle Atom \rangle \;\langle Prod' \rangle \\[6pt]

\langle Prod' \rangle 
    & \to & *\;\langle Atom \rangle \;\langle Prod' \rangle 
            \;\;|\;\; /\;\langle Atom \rangle \;\langle Prod' \rangle 
            \;\;|\;\; \epsilon \\[6pt]

\langle Atom \rangle 
    & \to & -\;\langle Atom \rangle 
            \;\;|\;\; [VarName] 
            \;\;|\;\; [Number] 
            \;\;|\;\; (\langle ExprArith \rangle)
\end{array}
\]


For boolean expressions, the final grammar adopts a different structure from the arithmetic case.
The implication operator \texttt{->} is right-associative, comparison operators bind more tightly,
and the language includes the absolute-value form \texttt{|Cond|}.  
This is encoded through the following productions:
\[
\begin{array}{rcl}
\langle Cond \rangle    
    & \to & \langle Imp \rangle \\[4pt]

\langle Imp \rangle     
    & \to & \langle AtomImp \rangle \;\langle Imp' \rangle \\[4pt]

\langle Imp' \rangle    
    & \to & \texttt{->}\;\langle Imp \rangle 
           \;\;|\;\; \epsilon \\[4pt]

\langle AtomImp \rangle 
    & \to & |\,\langle Cond \rangle\,| 
           \;\;|\;\; \langle Rel \rangle \\[4pt]

\langle Rel \rangle     
    & \to & \langle ExprArith \rangle \;\langle RelTail \rangle \\[4pt]

\langle RelTail \rangle 
    & \to & \langle Comp \rangle \;\langle ExprArith \rangle
\end{array}
\]


This structure ensures that:
\begin{itemize}
    \item comparisons (\texttt{==}, \texttt{<=}, \texttt{<}) have higher precedence,
    \item implications form right-associative chains,
    \item \texttt{|Cond|} acts as an atomic boolean expression.
\end{itemize}

By explicitly encoding precedence, associativity, and the boolean constructs in this
hierarchical manner, every expression has a unique parse tree. The grammar becomes
unambiguous and suitable for predictive LL(1) parsing.


\subsection{(c) Removing Left Recursion and Applying Factorization}

Even after resolving ambiguity, some rules of the original grammar remained left-recursive.
For instance:
\[
\langle ExprArith \rangle \to \langle ExprArith \rangle \; \langle Op \rangle \; \langle ExprArith \rangle
\]
was rewritten into the right-recursive and fully factored form described above.
Right recursion is essential for recursive–descent parsing, as left recursion would
lead to infinite recursion without consuming input.

The \texttt{If} rule also required left factoring. The original specification:
\[
\begin{aligned}
\langle If \rangle &\to If \{ \langle Cond \rangle \} Then \langle Code \rangle End \\
                  &\;|\; If \{ \langle Cond \rangle \} Then \langle Code \rangle Else \langle Code \rangle End
\end{aligned}
\]
contains a common prefix. With a single lookahead token, the parser cannot
distinguish whether the next keyword will be \texttt{Else} or \texttt{End}.  
To resolve this, we factorized the rule:
\[
\langle If \rangle \to If \{ \langle Cond \rangle \} Then \langle Code \rangle \langle IfTail \rangle
\]
\[
\langle IfTail \rangle \to Else \langle Code \rangle End \;|\; End
\]

All recursive occurrences are now rightmost, which ensures that each parsing step consumes input
and guarantees determinism. The transformations performed — elimination of left recursion, left
factoring, and precedence encoding — produce a grammar that is unambiguous, right-recursive, and
fully compatible with LL(1) predictive parsing.

With these structural issues resolved, we can now compute the FIRST and FOLLOW sets to verify
the LL(1) property formally.



\section{Final Grammar}
\subsection{Introduction to the Final Grammar}

After applying all transformations required in steps (a), (b), and (c), we obtain a new grammar 
that is unambiguous, left-recursion free, fully factorized, and therefore compatible with 
predictive LL(1) parsing. The grammar below is the \textbf{final specification} used in our 
recursive–descent parser.

All productions have been renumbered to ensure consistency with the leftmost derivation 
output required by the project instructions. This renumbering does not affect the semantics 
of the grammar but is essential for implementation.

To later justify that this grammar is LL(1), we compute its \texttt{FIRST} and \texttt{FOLLOW} 
sets. These sets are defined as follows:

\begin{itemize}
  \item \textbf{FIRST(A)} is the set of terminals that may begin a string derived from the 
  non-terminal $A$.
  \item \textbf{FOLLOW(A)} is the set of terminals that may immediately follow $A$ in any 
  valid derivation.
\end{itemize}

If one alternative of a non-terminal derives $\varepsilon$, we must additionally ensure that:
\[
\text{FIRST}(\beta) \cap \text{FOLLOW}(A) = \varnothing,
\]
for all other alternatives $\beta$ of $A$.  
These constraints are necessary to guarantee that the grammar satisfies the LL(1) property.

The final grammar and its computed \texttt{FIRST} / \texttt{FOLLOW} sets are presented below.
\newpage
\subsection{Complete final grammar}

\begin{lstlisting}[mathescape]
[1]  <Program>     -> Prog [ProgName] Is <Code> End
[2]  <Code>        -> <Instruction> ; <Code>
[3]                -> $\epsilon$
[4]  <Instruction> -> <Assign>
[5]                -> <If>
[6]                -> <While>
[7]                -> <Output>
[8]                -> <Input>
[9]  <Assign>      -> [VarName] = <ExprArith>
[10] <ExprArith>   -> <Prod> <ExprArith'>
[11] <ExprArith'>  -> <TermList>
[12] <TermList>    -> + <Prod> <TermList>
[13]               -> - <Prod> <TermList>
[14]               -> $\epsilon$
[15] <Prod>        -> <Atom> <Prod'>
[16] <Prod'>       -> <FactorList>
[17] <FactorList>  -> * <Atom> <FactorList>
[18]               -> / <Atom> <FactorList>
[19]               -> $\epsilon$
[20] <Atom>        -> - <Atom>
[21]               -> [VarName]
[22]               -> [Number]
[23]               -> ( <ExprArith> )
[24] <Rel>         -> <ExprArith> <RelTail>
[25] <RelTail>     -> <Comp> <ExprArith>
[26] <Comp>        -> ==
[27]               -> <=
[28]               -> <
[29] <Cond>        -> <Imp>
[30] <Imp>         -> <AtomImp> <Imp'>
[31] <Imp'>        -> -> <Imp>
[32]               -> $\epsilon$
[33] <AtomImp>     -> |<Cond>|
[34]               -> <Rel>
[35] <If>          -> If {<Cond>} Then <Code> <IfTail>
[36] <IfTail>      -> Else <Code> End
[37]               -> End
[38] <While>       -> While {<Cond>} Do <Code> End
[39] <Output>      -> Print([VarName])
[40] <Input>       -> Input([VarName])
\end{lstlisting}


\section{FIRST and FOLLOW Sets}
\subsubsection*{Computation of FIRST and FOLLOW Sets}

To verify the LL(1) property of the transformed grammar, we manually computed the 
\texttt{FIRST} and \texttt{FOLLOW} sets for all non-terminals.

The computation follows the classical iterative method:

\paragraph{FIRST sets.}
The FIRST set of a non-terminal is computed by:
\begin{itemize}
  \item adding terminals that appear at the beginning of its productions;
  \item propagating FIRST sets of non-terminals that appear first in a production;
  \item adding $\varepsilon$ if all symbols in a production may derive $\varepsilon$.
\end{itemize}

\paragraph{FOLLOW sets.}
The FOLLOW set of a non-terminal $A$ is computed by:
\begin{itemize}
  \item adding \$ to FOLLOW(StartSymbol);
  \item adding FIRST sets of the symbols that follow $A$ in every production;
  \item propagating FOLLOW sets of the left-hand non-terminals when $A$ appears at the end of a production;
  \item propagating FOLLOW sets through nullable symbols when necessary.
\end{itemize}

The resulting FIRST and FOLLOW sets are shown in the tables below.  
These sets are then used in Section~7 to justify that the grammar is indeed LL(1).


\subsection{FIRST sets}

\begin{lstlisting}[mathescape]
FIRST(Program)      = { Prog }

FIRST(Code)         = { [VarName], If, While, Print, Input, $\epsilon$ }

FIRST(Instruction)  = { [VarName], If, While, Print, Input }

FIRST(Assign)       = { [VarName] }

FIRST(ExprArith)    = { -, (, [VarName], [Number] }
FIRST(ExprArith')   = { +, -, $\epsilon$ }
FIRST(TermList)     = { +, -, $\epsilon$ }

FIRST(Prod)         = { -, (, [VarName], [Number] }
FIRST(Prod')        = { *, /, $\epsilon$ }
FIRST(FactorList)   = { *, /, $\epsilon$ }

FIRST(Atom)         = { -, (, [VarName], [Number] }

FIRST(Rel)          = { -, (, [VarName], [Number] }
FIRST(RelTail)      = { ==, <=, < }
FIRST(Comp)         = { ==, <=, < }

FIRST(Cond)         = { |, -, (, [VarName], [Number] }
FIRST(Imp)          = { |, -, (, [VarName], [Number] }
FIRST(Imp')         = { '->', $\epsilon$ }
FIRST(AtomImp)      = { |, -, (, [VarName], [Number] }

FIRST(If)           = { If }
FIRST(IfTail)       = { Else, End }

FIRST(While)        = { While }
FIRST(Output)       = { Print }
FIRST(Input)        = { Input }
\end{lstlisting}



\newpage
\subsection{FOLLOW sets}

\begin{lstlisting}
FOLLOW(Program)     = { '$' }

FOLLOW(Code)        = { End, Else }

FOLLOW(Instruction) = { ; }
FOLLOW(Assign)      = { ; }

FOLLOW(ExprArith)   = { ;, ), ==, <=, <, '->', '|', '}' }
FOLLOW(ExprArith')  = { ;, ), ==, <=, <, '->', '|', '}' }
FOLLOW(TermList)    = { ;, ), ==, <=, <, '->', '|', '}' }

FOLLOW(Prod)        = { +, -, ;, ), ==, <=, <, '->', '|', '}' }
FOLLOW(Prod')       = { +, -, ;, ), ==, <=, <, '->', '|', '}' }
FOLLOW(FactorList)  = { +, -, ;, ), ==, <=, <, '->', '|', '}' }

FOLLOW(Atom)        = { +, -, *, /, ;, ), ==, <=, <, '->', '|', '}' }

FOLLOW(Rel)         = { '->', '|', '}' }
FOLLOW(RelTail)     = { '->', '|', '}' }
FOLLOW(Comp)        = { -, (, [VarName], [Number] }

FOLLOW(Cond)        = { '|', '}' }
FOLLOW(Imp)         = { '|', '}' }
FOLLOW(Imp')        = { '|', '}' }
FOLLOW(AtomImp)     = { '->', '|', '}' }

FOLLOW(If)          = { ; }
FOLLOW(IfTail)      = { ; }
FOLLOW(While)       = { ; }
FOLLOW(Output)      = { ; }
FOLLOW(Input)       = { ; }
\end{lstlisting}







\subsection{LL(1) Grammar Verification and Final Form}

Once the grammar was disambiguated, factorized, and rewritten in a
right-recursive form, we computed all \textbf{FIRST} and \textbf{FOLLOW} sets in order
to verify the LL(1) property.

A grammar is LL(1) (also called strong LL(1)) if, for every non-terminal $A$
and for every pair of distinct alternatives $A \rightarrow \alpha_1$ and
$A \rightarrow \alpha_2$, the following condition holds:
\[
\mathrm{FIRST}(\alpha_1\,\mathrm{FOLLOW}(A)) \cap
\mathrm{FIRST}(\alpha_2\,\mathrm{FOLLOW}(A)) = \varnothing.
\]

Practically, this means that all alternatives of the same non-terminal
must be distinguishable based on a single look-ahead symbol. In the case of
nullable productions ($\alpha = \varepsilon$), the condition reduces to:
\[
\big(\mathrm{FIRST}(\alpha)\setminus\{\varepsilon\}\big)
\cap
\mathrm{FOLLOW}(A)
= \varnothing.
\]

We applied this test to all non-terminals of the grammar. For example,
$\mathrm{FIRST}(\langle ExprArith \rangle)=\{ -, (, [VarName], [Number] \}$ and
$\mathrm{FOLLOW}(\langle ExprArith \rangle)=\{ ;, ), ==, <=, <, \texttt{->}, \texttt{|},\texttt{"\}"} \}$.
Similarly, the nullable non-terminals
$\langle ExprArith' \rangle$, $\langle TermList \rangle$,
$\langle Prod' \rangle$, $\langle FactorList \rangle$ and $\langle Imp' \rangle$ all satisfy the LL(1)
constraint, since for each of them the FIRST/FOLLOW intersection
associated with the $\varepsilon$ alternative is empty.

Boolean constructs were checked as well. The rule
\[
\langle Imp' \rangle \to \texttt{->}\,\langle Imp \rangle \;|\; \varepsilon
\]
has clearly disjoint FIRST sets, and
$\mathrm{FOLLOW}(\langle Imp' \rangle)=\{ \texttt{|}, \texttt{)} \}$ does not
create any conflict with the non-$\varepsilon$ alternative. Likewise,
\[
\langle AtomImp \rangle \to |\,\langle Cond \rangle\,| \quad|\quad \langle Rel \rangle
\]
yields disjoint FIRST sets:
$\{|\}$ for the first alternative and
$\{-, (, [VarName], [Number]\}$ for the second.

Although certain non-terminals such as $\langle Cond \rangle$ present an
intersection between $\mathrm{FIRST}(A)$ and $\mathrm{FOLLOW}(A)$, this does not
violate the LL(1) conditions. An intersection becomes problematic only
when $A$ has an $\varepsilon$-production, because the parser must then
choose between using $\mathrm{FIRST}(A)$ or $\mathrm{FOLLOW}(A)$ to predict the
appropriate alternative. Since $\langle Cond \rangle$ does not derive
$\varepsilon$, its $\mathrm{FIRST}$ and $\mathrm{FOLLOW}$ sets can overlap
without creating any ambiguity.

All checks were therefore satisfied, and the resulting grammar is fully
LL(1)-compliant. The following section verifies these conditions for each
non-terminal and justifies the construction of the LL(1) parsing table.


\section{Justification that the Grammar is LL(1)}

As recalled in Section~6.3, a grammar is LL(1) if, for each non-terminal
$A$ and every pair of productions $A \rightarrow \alpha$ and
$A \rightarrow \beta$, the following conditions hold:

\begin{enumerate}
    \item The FIRST sets of $\alpha$ and $\beta$ are disjoint:
    \[
        \mathrm{FIRST}(\alpha) \cap \mathrm{FIRST}(\beta) = \varnothing.
    \]

    \item If $\varepsilon \in \mathrm{FIRST}(\alpha)$, then for every other
    alternative $\beta$ of $A$:
    \[
        \mathrm{FIRST}(\beta) \cap \mathrm{FOLLOW}(A) = \varnothing.
    \]
\end{enumerate}

We now verify these conditions for each non-terminal in the transformed grammar.


\subsection*{Program}
\[
Program \rightarrow Prog\ [ProgName]\ Is\ Code\ End
\]
There is only one production. No conflict is possible.  
\textbf{LL(1) satisfied.}

\subsection*{Code}
\[
Code \rightarrow Instruction\ ;\ Code \quad | \quad \epsilon
\]
We have:
\[
FIRST(Instruction) = \{ [VarName],\ If,\ While,\ Print,\ Input \},
\quad FIRST(\epsilon) = \{\epsilon\},
\]
\[
FOLLOW(Code) = \{ End,\ Else \}.
\]
There is no overlap between $FIRST(Instruction)$ and $FOLLOW(Code)$, and the FIRST sets of both alternatives are disjoint.  
\textbf{LL(1) satisfied.}

\subsection*{Instruction}
\[
Instruction \rightarrow Assign\ |\ If\ |\ While\ |\ Output\ |\ Input
\]
Each alternative begins with a distinct terminal.  
\textbf{No conflict → LL(1) satisfied.}

\subsection*{Assign}
\[
Assign \rightarrow [VarName]\ =\ ExprArith
\]
Single production.  
\textbf{LL(1) satisfied.}

\subsection*{ExprArith}
\[
ExprArith \rightarrow Prod\ ExprArith'
\]
Single production.  
\textbf{LL(1) satisfied.}

\subsection*{ExprArith'}
\[
ExprArith' \rightarrow TermList
\]

There is only one production. By construction we have
\[
FIRST(ExprArith') = FIRST(TermList) = \{ +,\ -,\, \varepsilon \}.
\]
All LL(1) conditions are therefore checked directly on the non-terminal
\texttt{TermList} (see the discussion for \texttt{TermList} below in the
action-table justification).  
\textbf{LL(1) satisfied.}

\subsection*{Rel}
\[
Rel \rightarrow ExprArith\ RelTail
\]
Single production.  
\textbf{LL(1) satisfied.}

\subsection*{RelTail}

\[
\langle RelTail \rangle \;\rightarrow\; \langle Comp \rangle\ \langle ExprArith \rangle
\]

Since \texttt{RelTail} has a \textbf{single production} and does \textbf{not} derive $\epsilon$, no FIRST/FOLLOW
conflict can occur. The grammar does not require any disambiguation step for this non-terminal.

\[
FIRST(RelTail)=\{==,\ <=,\ <\}
\]

Because there is no $\epsilon$-alternative, FOLLOW sets do not play any role in predicting the correct rule.

\textbf{LL(1) satisfied.}

\subsection*{Comp}
\[
Comp \rightarrow ==\ |\ <=\ |\ <
\]
Each alternative begins with a different terminal.  
\textbf{LL(1) satisfied.}

\subsection*{AtomImp}
\[
AtomImp \rightarrow |\,Cond\,|\ \quad|\quad Rel
\]
\[
FIRST(|\,Cond\,|)=\{\texttt{'|'}\}, \qquad FIRST(Rel)=\{-,\ (,\ [VarName],\ [Number]\}.
\]
These sets are disjoint.  
\textbf{LL(1) satisfied.}

\subsection*{Imp'}
\[
Imp' \rightarrow ->\ Imp\ |\ \epsilon
\]
\[
FIRST(->\ Imp)=\{\texttt{'->'}\}, \qquad FIRST(\epsilon)=\{\epsilon\},
\]
\[
FOLLOW(Imp') = \{ \texttt{'|'},\ \texttt{'}\} \} \}.
\]
No intersection occurs; thus the $\epsilon$-rule is safe.  
\textbf{LL(1) satisfied.}

\subsection*{Imp}
\[
Imp \rightarrow AtomImp\ Imp'
\]
Single production.  
\textbf{LL(1) satisfied.}

\subsection*{Cond}
\[
Cond \rightarrow Imp
\]
Single production.  
\textbf{LL(1) satisfied.}

\subsection*{IfTail}
\[
IfTail \rightarrow Else\ Code\ End \quad|\quad End
\]
\[
FIRST(Else\ Code\ End)=\{Else\}, \qquad FIRST(End)=\{End\}.
\]
These sets are disjoint.  
\textbf{LL(1) satisfied.}

\subsection*{If, While, Output, Input}
Each of these non-terminals has a single production.  
\textbf{LL(1) satisfied.}

\subsection*{Conclusion}
All non-terminals satisfy the LL(1) conditions:
\begin{itemize}
    \item FIRST sets of alternative productions are disjoint.
    \item For productions that include $\epsilon$, their FOLLOW sets do not conflict with the FIRST sets of the other alternatives.
\end{itemize}

\noindent\textbf{Therefore, the grammar is LL(1).}

\section{LL(1) Action Table and Justification}

The LL(1) parsing (action) table is constructed using the FIRST and FOLLOW sets
computed for the final transformed grammar.

For each non-terminal $A$ and each production $A \rightarrow \alpha$:

\begin{enumerate}
    \item Compute $FIRST(\alpha)$.
    \item For each terminal $a \in FIRST(\alpha)$ with $a \neq \epsilon$, place the production
    in the table entry:
    \[
        M[A,a] = A \rightarrow \alpha.
    \]
    \item If $\epsilon \in FIRST(\alpha)$, then for each terminal 
    $b \in FOLLOW(A)$, place:
    \[
        M[A,b] = A \rightarrow \alpha.
    \]
\end{enumerate}

All other entries $M[A,a]$ are error entries.  
This construction uses exactly the FIRST and FOLLOW sets computed in the previous section.

\subsection*{Justification with FIRST and FOLLOW Sets}

We now justify the non-error entries of the table for each non-terminal, using 
the relevant FIRST and FOLLOW sets.

\paragraph*{Program}

\[
Program \rightarrow Prog\ [ProgName]\ Is\ Code\ End
\]

There is only one production. Therefore:

\[
M[Program,\ Prog] = Program \rightarrow Prog\ [ProgName]\ Is\ Code\ End.
\]

\paragraph*{Code}

\[
Code \rightarrow Instruction\ ;\ Code \ \mid\ \epsilon
\]

We have:
\[
FIRST(Instruction) = \{[VarName], If, While, Print, Input\},
\quad FIRST(\epsilon) = \{\epsilon\},
\]
\[
FOLLOW(Code) = \{End, Else\}.
\]

Thus:

\[
\begin{aligned}
M[Code,\ [VarName]] &= Code \rightarrow Instruction\ ;\ Code,\\
M[Code,\ If]        &= Code \rightarrow Instruction\ ;\ Code,\\
M[Code,\ While]     &= Code \rightarrow Instruction\ ;\ Code,\\
M[Code,\ Print]     &= Code \rightarrow Instruction\ ;\ Code,\\
M[Code,\ Input]     &= Code \rightarrow Instruction\ ;\ Code,\\[0.2em]
M[Code,\ End]       &= Code \rightarrow \epsilon,\\
M[Code,\ Else]      &= Code \rightarrow \epsilon.
\end{aligned}
\]

There is no conflict: the FIRST sets of the alternatives are disjoint, and
$FIRST(\epsilon)$ does not clash with $FOLLOW(Code)$.

\paragraph*{Instruction}

\[
Instruction \rightarrow Assign\ \mid\ If\ \mid\ While\ \mid\ Output\ \mid\ Input
\]

The FIRST sets of the alternatives are:

\[
FIRST(Assign) = \{[VarName]\},\quad
FIRST(If) = \{If\},\quad
FIRST(While) = \{While\},\quad
FIRST(Output) = \{Print\},\quad
FIRST(Input) = \{Input\},
\]

which are pairwise disjoint. The corresponding table entries are:

\[
\begin{aligned}
M[Instruction,\ [VarName]] &= Instruction \rightarrow Assign,\\
M[Instruction,\ If]        &= Instruction \rightarrow If,\\
M[Instruction,\ While]     &= Instruction \rightarrow While,\\
M[Instruction,\ Print]     &= Instruction \rightarrow Output,\\
M[Instruction,\ Input]     &= Instruction \rightarrow Input.
\end{aligned}
\]

\paragraph*{Assign}

\[
Assign \rightarrow [VarName]\ =\ ExprArith
\]

Only one production; we obtain:

\[
M[Assign,\ [VarName]] = Assign \rightarrow [VarName]\ =\ ExprArith.
\]

\paragraph*{ExprArith}

\[
ExprArith \rightarrow Prod\ ExprArith'
\]

With
\[
FIRST(Prod) = \{-, (, [VarName], [Number]\},
\]
we have:

\[
\begin{aligned}
M[ExprArith,\ -]         &= ExprArith \rightarrow Prod\ ExprArith',\\
M[ExprArith,\ (]         &= ExprArith \rightarrow Prod\ ExprArith',\\
M[ExprArith,\ [VarName]] &= ExprArith \rightarrow Prod\ ExprArith',\\
M[ExprArith,\ [Number]]  &= ExprArith \rightarrow Prod\ ExprArith'.
\end{aligned}
\]

\paragraph*{ExprArith'}

\[
ExprArith' \rightarrow TermList
\]

There is only one production. Since
\[
FIRST(TermList) = FIRST(ExprArith') = \{+, -, \epsilon\},
\]
we get:
\[
M[ExprArith',\ +] = ExprArith' \rightarrow TermList,\quad
M[ExprArith',\ -] = ExprArith' \rightarrow TermList.
\]
The internal choice between $+$, $-$, or $\epsilon$ is handled at non-terminal
\texttt{TermList} (see below).

\paragraph*{TermList}

\[
TermList \rightarrow +\ Prod\ TermList\ \mid\ -\ Prod\ TermList\ \mid\ \epsilon
\]

\[
FIRST(+\dots) = \{+\},\quad FIRST(-\dots) = \{-\},\quad FIRST(\epsilon) = \{\epsilon\},
\]
\[
FOLLOW(TermList) = \{ ;,\ ), ==, <=, <, ->, |,\ \}\}.
\]

Thus:

\[
\begin{aligned}
M[TermList,\ +] &= TermList \rightarrow +\ Prod\ TermList,\\
M[TermList,\ -] &= TermList \rightarrow -\ Prod\ TermList,\\
\text{for all } a \in FOLLOW(TermList):\quad
M[TermList,\ a] &= TermList \rightarrow \epsilon.
\end{aligned}
\]

The FIRST sets of the non-$\epsilon$ alternatives are disjoint, and
$FOLLOW(TermList)$ does not intersect $\{+,-\}$, hence the LL(1) conditions are satisfied.

\paragraph*{Prod}

\[
Prod \rightarrow Atom\ Prod'
\]

With
\[
FIRST(Atom) = \{-, (, [VarName], [Number]\},
\]
we obtain:

\[
\begin{aligned}
M[Prod,\ -]         &= Prod \rightarrow Atom\ Prod',\\
M[Prod,\ (]         &= Prod \rightarrow Atom\ Prod',\\
M[Prod,\ [VarName]] &= Prod \rightarrow Atom\ Prod',\\
M[Prod,\ [Number]]  &= Prod \rightarrow Atom\ Prod'.
\end{aligned}
\]

\paragraph*{Prod'}

\[
Prod' \rightarrow FactorList
\]

A single production; the branching is handled by \texttt{FactorList}.

\paragraph*{FactorList}

\[
FactorList \rightarrow *\ Atom\ FactorList\ \mid\ /\ Atom\ FactorList\ \mid\ \epsilon
\]

\[
FIRST(*\dots) = \{*\},\quad FIRST(/\dots) = \{/ \},\quad FIRST(\epsilon) = \{\epsilon\},
\]
\[
FOLLOW(FactorList) = \{ +, -, ;, ), ==, <=, <, ->, |,\ \}\}.
\]

Thus:

\[
\begin{aligned}
M[FactorList,\ *] &= FactorList \rightarrow *\ Atom\ FactorList,\\
M[FactorList,\ /] &= FactorList \rightarrow /\ Atom\ FactorList,\\
\text{for all } a \in FOLLOW(FactorList):\quad
M[FactorList,\ a] &= FactorList \rightarrow \epsilon.
\end{aligned}
\]

Again, the FIRST sets are disjoint and $FOLLOW(FactorList)$ does not contain
$*$ or $/$, so the LL(1) condition holds.

\paragraph*{Atom}

\[
Atom \rightarrow -\ Atom\ \mid\ [VarName]\ \mid\ [Number]\ \mid\ (\,ExprArith\,)
\]

\[
FIRST(Atom) = \{-, (, [VarName], [Number]\},
\]
with each alternative starting with a distinct terminal. The corresponding entries are:

\[
\begin{aligned}
M[Atom,\ -]         &= Atom \rightarrow -\ Atom,\\
M[Atom,\ [VarName]] &= Atom \rightarrow [VarName],\\
M[Atom,\ [Number]]  &= Atom \rightarrow [Number],\\
M[Atom,\ (]         &= Atom \rightarrow (\,ExprArith\,).
\end{aligned}
\]

\paragraph*{Rel}

\[
Rel \rightarrow ExprArith\ RelTail
\]

Since
\[
FIRST(ExprArith) = \{-, (, [VarName], [Number]\},
\]
we obtain, for all $t$ in this set:
\[
M[Rel,\ t] = Rel \rightarrow ExprArith\ RelTail.
\]

\paragraph*{RelTail}

\[
\langle RelTail \rangle \rightarrow \langle Comp \rangle\ \langle ExprArith \rangle
\]

Since there is only one production for $\langle RelTail \rangle$, we have
\[
FIRST(\langle RelTail \rangle) = \{==,\ <=,\ <\}.
\]

Therefore:
\[
\begin{aligned}
M[\langle RelTail \rangle,\ ==] &= \langle RelTail \rangle \rightarrow \langle Comp \rangle\ \langle ExprArith \rangle,\\
M[\langle RelTail \rangle,\ <=] &= \langle RelTail \rangle \rightarrow \langle Comp \rangle\ \langle ExprArith \rangle,\\
M[\langle RelTail \rangle,\ < ] &= \langle RelTail \rangle \rightarrow \langle Comp \rangle\ \langle ExprArith \rangle.
\end{aligned}
\]

For all other terminals, the entry for $\langle RelTail \rangle$ is an error.
Since there is only one production, the non–terminal $\langle RelTail \rangle$
is trivially LL(1).

\paragraph*{Comp}

\[
Comp \rightarrow ==\ \mid\ <=\ \mid\ <
\]

Each alternative starts with a distinct terminal:

\[
\begin{aligned}
M[Comp,\ ==] &= Comp \rightarrow ==,\\
M[Comp,\ <=] &= Comp \rightarrow <=,\\
M[Comp,\ <]  &= Comp \rightarrow <.
\end{aligned}
\]

\paragraph*{Cond}

\[
Cond \rightarrow Imp
\]

Single production. For all $t \in \{|,\ -, (, [VarName], [Number]\}$:
\[
M[Cond,\ t] = Cond \rightarrow Imp.
\]

\paragraph*{Imp}

\[
Imp \rightarrow AtomImp\ Imp'
\]

Single production. For all $t \in \{|,\ -, (, [VarName], [Number]\}$:
\[
M[Imp,\ t] = Imp \rightarrow AtomImp\ Imp'.
\]

\paragraph*{Imp'}

\[
Imp' \rightarrow ->\ Imp\ \mid\ \epsilon
\]

\[
FIRST(->\ Imp) = \{->\},\quad FIRST(\epsilon) = \{\epsilon\},
\]
\[
FOLLOW(Imp') = \{ |,\ \}\}.
\]

Thus:

\[
\begin{aligned}
M[Imp',\ ->] &= Imp' \rightarrow ->\ Imp,\\
\text{for all } b \in FOLLOW(Imp'):\quad
M[Imp',\ b] &= Imp' \rightarrow \epsilon.
\end{aligned}
\]

There is no intersection between $\{->\}$ and $FOLLOW(Imp')$, so the LL(1) condition is satisfied.

\paragraph*{AtomImp}

\[
AtomImp \rightarrow |\,Cond\,|\ \mid\ Rel
\]

\[
FIRST(|\,Cond\,|) = \{| \},\quad FIRST(Rel) = \{-, (, [VarName], [Number]\},
\]
which are disjoint. Therefore:

\[
\begin{aligned}
M[AtomImp,\ |] &= AtomImp \rightarrow |\,Cond\,|,\\
\text{for all } t \in \{-, (, [VarName], [Number]\}:\quad
M[AtomImp,\ t] &= AtomImp \rightarrow Rel.
\end{aligned}
\]

\paragraph*{If}

\[
If \rightarrow If\ \{\,Cond\,\}\ Then\ Code\ IfTail
\]

Single production:

\[
M[If,\ If] = If \rightarrow If\ \{\,Cond\,\}\ Then\ Code\ IfTail.
\]

\paragraph*{IfTail}

\[
IfTail \rightarrow Else\ Code\ End\ \mid\ End
\]

\[
FIRST(Else\ Code\ End) = \{Else\},\quad FIRST(End) = \{End\},
\]
so:

\[
\begin{aligned}
M[IfTail,\ Else] &= IfTail \rightarrow Else\ Code\ End,\\
M[IfTail,\ End]  &= IfTail \rightarrow End.
\end{aligned}
\]

\paragraph*{While}

\[
While \rightarrow While\ \{\,Cond\,\}\ Do\ Code\ End
\]

Single production:

\[
M[While,\ While] = While \rightarrow While\ \{\,Cond\,\}\ Do\ Code\ End.
\]

\paragraph*{Output}

\[
Output \rightarrow Print([VarName])
\]

Single production:

\[
M[Output,\ Print] = Output \rightarrow Print([VarName]).
\]

\paragraph*{Input}

\[
Input \rightarrow Input([VarName])
\]

Single production:

\[
M[Input,\ Input] = Input \rightarrow Input([VarName]).
\]

\paragraph{Note on the structure of the LL(1) table.}
A common misunderstanding is that each non-terminal should appear with only 
one production in its corresponding row of the LL(1) table. This is not 
required. Since many non-terminals in the grammar have multiple alternatives 
(e.g., $Code \rightarrow Instruction\ ;\ Code$ and $Code \rightarrow \epsilon$), 
it is normal for a row to contain several different production numbers.

What the LL(1) property strictly requires is that \emph{each table entry} 
$M[A, a]$ contains \textbf{at most one} production.  
That is, for every pair consisting of a non-terminal $A$ and a terminal $a$, 
the parser must never face a choice between two different productions.  
In our table, every cell contains either a single production or an error 
entry, which confirms that the grammar is indeed LL(1).

\subsection*{LL(1) action table – statements}



Terminals (columns): $\{ Prog,\ [VarName],\ If,\ While,\ Print,\ Input,\ End,\ Else \}$



\begin{center}

\resizebox{\textwidth}{!}{

\begin{tabular}{l|cccccccc}

\toprule

Non-terminal 

 & Prog & [VarName] & If & While & Print & Input & End & Else \\

\midrule

Program 

 & [1] & error & error & error & error & error & error & error \\



Code 

 & error 

 & [2] 

 & [2] 

 & [2] 

 & [2] 

 & [2] 

 & [3] 

 & [3] \\



Instruction 

 & error 

 & [4] 

 & [5] 

 & [6] 

 & [7] 

 & [8] 

 & error 

 & error \\



Assign 

 & error 

 & [9] 

 & error 

 & error 

 & error 

 & error 

 & error 

 & error \\



If 

 & error 

 & error 

 & [35] 

 & error 

 & error 

 & error 

 & error 

 & error \\



IfTail 

 & error 

 & error 

 & error 

 & error 

 & error 

 & error 

 & [37] 

 & [36] \\



While 

 & error 

 & error 

 & error 

 & [38] 

 & error 

 & error 

 & error 

 & error \\



Output 

 & error 

 & error 

 & error 

 & error 

 & [39] 

 & error 

 & error 

 & error \\



Input 

 & error 

 & error 

 & error 

 & error 

 & error 

 & [40] 

 & error 

 & error \\

\bottomrule

\end{tabular}

}

\end{center}



\subsection*{LL(1) action table – arithmetic and relations}

Terminals (columns): 
$\{ [VarName],\ [Number],\ -,\, (,\, +,\, *,\, /,\, ),\, ;,\, ==,\, <=,\, <,\, |,\, ->,\, \} \}$

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l|ccccccccccccccc}
\toprule
Non-term.
 & \texttt{[VarName]} & \texttt{[Number]} & \texttt{-} & \texttt{(} 
 & \texttt{+} & \texttt{*} & \texttt{/} & \texttt{)} & \texttt{;} 
 & \texttt{==} & \texttt{<=} & \texttt{<} & \texttt{|} & \texttt{->} & \texttt{\}} \\
\midrule
ExprArith 
 & [10] & [10] & [10] & [10] 
 & error & error & error 
 & error & error & error & error & error & error & error & error \\

ExprArith' 
 & error & error 
 & [11] & error 
 & [11] & error & error 
 & [11] & [11] 
 & [11] & [11] & [11] & [11] & [11] & [11] \\

TermList 
 & error & error 
 & [13] & error 
 & [12] & error & error 
 & [14] & [14] 
 & [14] & [14] & [14] & [14] & [14] & [14] \\

Prod 
 & [15] & [15] & [15] & [15] 
 & error & error & error 
 & error & error & error & error & error & error & error & error \\

Prod' 
 & error & error 
 & [16] & error 
 & [16] & [16] & [16] 
 & [16] & [16] 
 & [16] & [16] & [16] & [16] & [16] & [16] \\

FactorList 
 & error & error 
 & [19] & error 
 & [19] & [17] & [18] 
 & [19] & [19] 
 & [19] & [19] & [19] & [19] & [19] & [19] \\

Atom 
 & [21] & [22] & [20] & [23] 
 & error & error & error 
 & error & error & error & error & error & error & error & error \\

RelTail 
 & error & error & error & error 
 & error & error & error 
 & error & error 
 & [25] & [25] & [25] & error & error & error \\


Rel 
 & [24] & [24] & [24] & [24] 
 & error & error & error 
 & error & error & error & error & error & error & error & error \\

Comp 
 & error & error & error & error 
 & error & error & error 
 & error & error 
 & [26] & [27] & [28] 
 & error & error & error \\
\bottomrule
\end{tabular}
}
\end{center}


\subsection*{LL(1) action table – conditions and implications}

Terminals (columns): $\{ |,\ [VarName],\ [Number],\ -,\, (,\, ->,\, \} \}$

\begin{center}
\begin{tabular}{l|ccccccc}
\toprule
Non-term.
 & \texttt{|}
 & \texttt{[VarName]}
 & \texttt{[Number]}
 & \texttt{-}
 & \texttt{(}
 & \texttt{->}
 & \texttt{\}} \\
\midrule
Cond 
 & [29] & [29] & [29] & [29] & [29] & error & error \\

Imp 
 & [30] & [30] & [30] & [30] & [30] & error & error \\

Imp' 
 & [32] & error & error & error & error & [31] & [32] \\

AtomImp 
 & [33] & [34] & [34] & [34] & [34] & error & error \\
\bottomrule
\end{tabular}
\end{center}




\section{Complete Action table}
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|*{29}{c|}}
\hline
 & \texttt{Prog}
 & \texttt{[ProgName]}
 & \texttt{Is}
 & \texttt{End}
 & \texttt{If}
 & \texttt{Then}
 & \texttt{Else}
 & \texttt{While}
 & \texttt{Do}
 & \texttt{Print}
 & \texttt{Input}
 & \texttt{[VarName]}
 & \texttt{[Number]}
 & \texttt{=}
 & \texttt{+}
 & \texttt{-}
 & \texttt{*}
 & \texttt{/}
 & \texttt{(}
 & \texttt{)}
 & \texttt{\{}
 & \texttt{\}}
 & \texttt{;}
 & \texttt{==}
 & \texttt{<=}
 & \texttt{<}
 & \texttt{|}
 & \texttt{->}
 & \texttt{\$} \\
\hline

Program 
& 1 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & \\
\hline

Code
&  &  &  & 3 & 2 &  & 3 & 2 &  & 2 & 2 & 2 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & \\
\hline

Instruction
&  &  &  &  & 5 &  &  & 6 &  & 7 & 8 & 4 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & \\
\hline

Assign
&  &  &  &  &  &  &  &  &  &  &  & 9 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & \\
\hline

ExprArith
&  &  &  &  &  &  &  &  &  &  &  & 10 & 10 &  &  & 10 &  &  & 10 &  &  &  &  &  &  &  &  &  & \\
\hline

ExprArith'
&  &  &  &  &  &  &  &  &  &  &  &  &  &  & 11 & 11 &  &  &  & 11 &  & 11 & 11 & 11 & 11 & 11 & 11 &   &\\
\hline

TermList
&  &  &  &  &  &  &  &  &  &  &  &  &  &  & 12 & 13 &  &  &  & 14 &  & 14 & 14 & 14 & 14 & 14 & 14 &  &  \\
\hline

Prod
&  &  &  &  &  &  &  &  &  &  &  & 15 & 15 &  &  & 15 &  &  & 15 &  &  &  &  &  &  &  &  &   &\\
\hline

Prod'
&  &  &  &  &  &  &  &  &  &  &  &  &  &  & 16 & 16 & 16 & 16 &  & 16 &  & 16 & 16 & 16 & 16 & 16 & 16 &   &\\
\hline

FactorList
&  &  &  &  &  &  &  &  &  &  &  &  &  &  & 19 & 19 & 17 & 18 &  & 19 &  & 19 & 19 & 19 & 19 & 19 & 19 &  & \\
\hline

Atom
&  &  &  &  &  &  &  &  &  &  &  & 21 & 22 &  &  & 20 &  &  & 23 &  &  &  &  &  &  &  &  &  & \\
\hline

Rel
&  &  &  &  &  &  &  &  &  &  &  & 24 & 24 &  &  & 24 &  &  & 24 &  &  &  &  &  &  &  &  &  & \\
\hline

RelTail
&  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & 25 & 25 & 25 &  &  & \\
\hline

Comp
&  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & 26 & 27 & 28 &  &  & \\
\hline

Cond
&  &  &  &  &  &  &  &  &  &  &  & 29 & 29 &  &  & 29 &  &  & 29 &  &  &  &  &  &  &  & 29 &  & \\
\hline

Imp
&  &  &  &  &  &  &  &  &  &  &  & 30 & 30 &  &  & 30 &  &  & 30 &  &  &  &  &  &  &  & 30 &  & \\
\hline

Imp'
&  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & 32 &  &  &  &  &  & 31 & 31 &   \\
\hline

AtomImp
&  &  &  &  &  &  &  &  &  &  &  & 34 & 34 &  &  & 34 &  &  & 34 &  &  &  &  &  &  &  & 33 &  & \\
\hline

If
&  &  &  &  & 35 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & \\
\hline

IfTail
&  &  & 37 &  &  & 36 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & \\
\hline

While
&  &  &  &  &  &  &  & 38 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &   & \\
\hline

Output
&  &  &  &  &  &  &  &  &  & 39 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &   & \\
\hline

Input
&  &  &  &  &  &  &  &  &  &  & 40 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\
\hline

\end{tabular}
}
\caption{Table LL(1) — action table}
\end{table}














\section{Implementation of the LL(1) Parser}
Having defined and verified the LL(1) grammar, we now present the architecture and implementation
choices of the recursive–descent parser developed in Java.
The parser is structured around a set of mutually recursive methods, one for each non-terminal of
the grammar. In addition to these parsing functions defined in the main parsing class, some auxiliary classes support the
construction of the parse tree and the representation of  the grammar symbols.

This section gives an overview of the core components involved:
\begin{itemize}
\item the \texttt{Parser} class, which implements the LL(1) parsing algorithms and the grammar productions;
\item the \texttt{ParseTree} class, which help builds the syntactic derivation tree in latex;
\item the modifications added to the \texttt{Symbol} class(which was used in part 1 of the project)  supporting the derivation output and tree construction;
\item the \texttt{Main} class, which integrates the scanner and the parser to build the left most derivation list.
\end{itemize}

Our implementation directly follows the final version of the grammar.
Each non-terminal of the grammar is mapped to a dedicated method in the parser, and the behaviour of these methods is determined by the LL(1) rules studied earlier.
This means that every parsing decision is made using only one lookahead token, and no backtracking is needed.









\subsection{Design of the Parser Class}

The \texttt{Parser} class is the central component of the syntactic analysis.
It consumes the token stream produced by the lexical analyzer and attempts to derive the input
according to the grammar rules. Each method in the parser corresponds to a specific grammar
production and implements it deterministically using the lookahead of 1.

\subsubsection*{Token Management and Lookahead}
At any given time, the parser maintains a single lookahead token, obtained from the lexer.
This fulfils the “1” in LL(1). The parser checks the lookahead before selecting a production.
If the lookahead does not match any terminal in the FIRST set of the current non-terminal,
a syntax error is thrown.

Advancing the input is centralized through a method \texttt{match(LexicalUnit expected)}, which:
\begin{enumerate}
\item verifies that the lookahead token matches \texttt{expected} which is a token;
\item if it matches requests the next token from the lexer to get the next symbol of lookahead or throw an syntax Exception if 
it doesn't match.
\end{enumerate}













\subsubsection*{Structure of the Parser and Methods for Non-Terminals}

The \texttt{Parser} class is a direct implementation of a recursive--descent LL(1) parser.
Each non-terminal of the grammar is represented by one dedicated Java method
(\texttt{parseCode}, \texttt{parseInstruction}, \texttt{parseExprArith}, etc.), and the algorithms inside these methods strictly follows the LL(1) structure of the grammar.

Unlike the theoretical description, the implementation does not rely on explicit tables of
FIRST and FOLLOW sets. Instead, these sets are encoded directly into the code through
compact helper such as \texttt{isFirstOfInstruction}, 
\texttt{isInFollowOfCode}, or \texttt{isInFollowOfFactorList}.  
This keeps the parser readable.

\paragraph{Method structure.}
Each parsing method follows the same overall pattern:
\begin{enumerate}
    \item \textbf{Select the production.}  
          The parser inspects \texttt{lookahead.getType()} to identify which grammar rule must be
          applied. This corresponds to FIRST/FOLLOW reasoning implemented through
          \texttt{if}/\texttt{else} blocks.
    \item \textbf{Record the rule number.}  
          The call to \texttt{pushRule(n)} store the derivation rule, printed later by
          \texttt{printDerivation()}.
    \item \textbf{Match the terminals.}  
          The \texttt{match(expected)} method consumes the next token or raises a
          \texttt{SyntaxException} if the token does not match.
    \item \textbf{Recursive descent.}  
          Non-terminals appearing on the right-hand side are parsed by calling their associated
          methods in order.
    \item \textbf{Optional parse tree construction.}  
          When the \texttt{buildTree} flag is set, the method creates a \texttt{ParseTree} node and
          attaches the children as the recursive calls unfold.  
          Without this flag, the same parsing logic applies but no tree nodes are created.
\end{enumerate}

This design guarantees that the parser remains deterministic: at each step, the lookahead
token uniquely identifies the correct production, so no backtracking is ever required.

\paragraph{Example: arithmetic expressions.}
Consider the rule
\[
\langle ExprArith \rangle \to \langle Prod \rangle \; \langle ExprArith' \rangle.
\]
In the implementation, the method \texttt{parseExprArith()} simply calls
\texttt{parseProd()} followed by \texttt{parseExprArithPrime()}, and optionally wraps both
subtrees into a \texttt{ParseTree} node.  
This pattern is applied consistently across the grammar, including relational expressions,
implication operators, \texttt{if}/\texttt{else} constructs, and the \texttt{while} loop.

\paragraph{FIRST/FOLLOW utility methods.}
The helper functions at the bottom of the class (\texttt{isFirstOfInstruction},
\texttt{isInFollowOfFactorList}, etc.) play the role of FIRST and FOLLOW sets:  
they resolve ambiguity and indicate when an $\varepsilon$-production must be used.
For instance, \texttt{parseCode()} decides whether to parse another instruction or apply the
$\varepsilon$-rule depending on whether the lookahead token lies in FIRST(Code) or
FOLLOW(Code).































\subsection{Construction of the Parse Tree}

The construction of the parse tree is handled by the \texttt{ParseTree} class.  
Whenever the parser applies a production rule, it creates a new tree node whose
label corresponds to the grammar symbol (terminal or non-terminal) on the left-hand side,
and then attaches child nodes for each symbol on the right-hand side.

This structure allows the tree to reflect exactly how the input program is reduced
according to the grammar.

\subsubsection*{Tree Node Structure}

Each node of the tree contains:
\begin{itemize}
    \item the \emph{Symbol} it represents (terminal or non-terminal);
    \item a list of children, stored as \texttt{List<ParseTree>};
    \item for terminal nodes, the concrete lexeme (number, variable name, operator, etc.),
          which is carried by the \texttt{Symbol}.
\end{itemize}

Since the grammar is designed to be LL(1) and right-recursive, the resulting tree closely
matches the syntactic structure of the language.  
Nested expressions, conditionals, and sequences of instructions naturally appear inside
the tree as hierarchical blocks.




\subsection{Extension of the \texttt{Symbol} Class}

To support the parse tree visualisation, we extended the
\texttt{Symbol} class with an additional functionality.  
The addition is the method \texttt{toTexString()}, which converts any symbol
into a LaTeX-safe string suitable for use in \texttt{forest} or TikZ environments.

The new features provide:

\begin{itemize}
    \item a distinction between terminal and non-terminal symbols;
    \item a uniform mechanism to represent non-terminals using the standard notation
          \texttt{<NonTerminal>} when generating the parse tree;
    \item automatic escaping of special LaTeX characters (\texttt{\$, \_, \%, \#, \{, \}}, etc.);
    \item a readable string form for printing derivations and debugging.
\end{itemize}

A non-terminal is therefore displayed as \verb|<Name>|, while a terminal is shown
using its concrete token name.  
This unified representation ensures that the structure of the tree printed from
\texttt{ParseTree} matches exactly the sequence of reductions used during parsing.

The following method implements this behaviour:

\begin{verbatim}
public String toTexString() {
    String s;

    if (this.isTerminal()) {
        if (this.value != null) s = this.value.toString();
        else if (this.type != null) s = this.type.toString();
        else s = "TERMINAL";
    } else {
        if (this.value != null) s = "<" + this.value.toString() + ">";
        else s = "$<NON_TERMINAL>$";
    }

    // Escape LaTeX special characters
    s = s.replace("\\", "\\textbackslash{}")
         .replace("_", "\\_")
         .replace("#", "\\#")
         .replace("$", "\\$")
         .replace("%", "\\%")
         .replace("&", "\\&")
         .replace("{", "\\{")
         .replace("}", "\\}")
         .replace("^", "\\textasciicircum{}")
         .replace("~", "\\textasciitilde{}");

    return s;
}
\end{verbatim}


\subsection{Role of the \texttt{Main} Class}

The \texttt{Main} class serves as the entry point of the syntactic analysis pipeline.
Its role is to orchestrate the interaction between the scanner, the parser,
and the optional construction of the parse tree.

Its behaviour can be summarised as follows:

\begin{enumerate}
    \item It interprets the command-line arguments.  
          Using \texttt{-wt} activates the parse tree construction mode and specifies
          the output file in which the tree's LaTeX code will be written.

    \item It initializes the lexical analyzer (\texttt{LexicalAnalyzer}) with the input file.

    \item It creates a \texttt{Parser} instance and invokes
          \texttt{parser.parseProgram()} to start the analysis from the grammar's
          start symbol.

    \item Upon successful parsing:
    \begin{itemize}
        \item it prints the leftmost derivation produced by the parser;
        \item if \texttt{-wt} is active, it writes the LaTeX representation of the
              parse tree using \texttt{ParseTree.toLaTeX()} in the /more folder.
    \end{itemize}

    \item It handles several kinds of errors:
    \begin{itemize}
        \item \texttt{FileNotFoundException} (input file cannot be opened);
        \item \texttt{UnkownLexicalUnitException} (scanner encountered an invalid token);
        \item \texttt{SyntaxException} (parser encountered an unexpected token).
    \end{itemize}
\end{enumerate}

The \texttt{Main} class therefore links all components of the front-end and provides
the user-facing interface to run the syntactic analyser in either normal mode
or tree-generation mode.

\subsection{Summary}

Our parser is a straightforward, from scratch, implementation of the LL(1) approach, closely following the structure of the transformed grammar.  
Each non-terminal in the grammar corresponds to a dedicated method in the \texttt{Parser} class, which uses lookahead tokens to deterministically choose the correct production and recursively expand it.  

The \texttt{ParseTree} class captures the program's syntactic structure, while the extended \texttt{Symbol} class provides a uniform representation for terminals and non-terminals for a latex friendly output.  

Finally, the \texttt{Main} class ties everything together, handling input, invoking the parser, printing the derivation, and optionally generating a LaTeX representation of the parse tree.  
Overall, the system is deterministic, predictable, and faithful to the grammar and LL(1) principles.

\subsection*{Note on Parser Output}
Before discussing the test results, we briefly recall what the parser outputs.
The \emph{leftmost derivation} is the sequence of grammar rules applied while
always expanding the leftmost non-terminal in the current sentential form.  
Since the final grammar is LL(1), this derivation is deterministic: each rule is
selected based exclusively on the current non-terminal and the lookahead symbol.

The second output is the \emph{parse tree}, a hierarchical representation of the
program in which each internal node corresponds to a non-terminal and its
children correspond to the right-hand side of the selected production.  
Nullable productions appear explicitly as $\varepsilon$ leaves.

Together, the derivation and the parse tree provide a clear and complete view of
how the program is parsed according to the grammar.


\section{Testing and Validation}

To ensure that the LL(1) parser correctly implements the final grammar, we executed a series of systematic tests covering all syntactic constructs of the language.  
These tests verify the correctness of the derivations, the structure of the parse trees, and the handling of both valid and invalid programs.  
All test files are located in the \texttt{test/} directory and are executed automatically using the Makefile targets described earlier.

The parser was tested in two modes:

\begin{itemize}
    \item \textbf{Standard mode} (\texttt{make run FILE=...})  
          Prints the leftmost derivation or a syntax error message.

    \item \textbf{Tree mode} (\texttt{make runWT FILE=...})  
          Generates a \texttt{.tex} file containing the full LaTeX parse tree (Forest package), 
          compiles it to \texttt{.pdf}, and removes all LaTeX temporary files.
\end{itemize}

Additionally, the command \texttt{make runWTTest} applies this process to every file in \texttt{test/}, generating a complete suite of parse-tree PDFs in the \texttt{more/} directory.

\subsection{11.1 Testing Methodology}

The purpose of the test suite is threefold:

\begin{enumerate}
    \item \textbf{Check the correctness of the LL(1) derivation.}  
          Each program produces a deterministic leftmost derivation according to the 40 grammar rules.

    \item \textbf{Validate the structure of the parse tree.}  
          The resulting tree must correspond exactly to the productions used during parsing.

    \item \textbf{Verify that FIRST/FOLLOW decisions apply correctly.}  
          In particular, epsilon-rules must be selected only when the lookahead belongs to FOLLOW.
\end{enumerate}

The tests cover: valid simple programs, nested conditionals, implications, arithmetic expressions,
loops, whitespace handling, comments, and various error cases such as unclosed comments or invalid program names.

\subsection{Example Test: \texttt{TooMuchSpace.ycc}}

We illustrate the behaviour of our parser using a simple example containing excessive whitespace:

\begin{verbatim}
!! Too much space test !!

Prog MyProgram    Is    
  Input(a)   ;   
  Print(a)   ;   
End
\end{verbatim}

Even though the code contains irregular spacing, the lexical analyzer collapses whitespace and produces the correct sequence of tokens.  
Running the test using:

\begin{verbatim}
make runWT FILE=test/TooMuchSpace.ycc
\end{verbatim}

produces:

\begin{verbatim}
Initialization
Variables
a 4
Done
Leftmost derivation:
1 2 8 40 2 7 39 3
Parse tree written to more/TooMuchSpace.tex
==> Compiling more/TooMuchSpace.tex to PDF...
\end{verbatim}

The derivation corresponds to:

\begin{itemize}
    \item Rule 1 : \texttt{<Program>}
    \item Rule 2 : \texttt{<Code> → <Instruction> ; <Code>}
    \item Rule 8 : \texttt{<Instruction> → <Input>}
    \item Rule 40 : \texttt{<Input>}
    \item Rule 2 : second instruction
    \item Rule 7 : \texttt{<Instruction> → <Output>}
    \item Rule 39 : \texttt{<Output>}
    \item Rule 3 : \texttt{<Code> → ε}
\end{itemize}

This matches the expected structure for:
\begin{center}
\texttt{Input(a);} \\
\texttt{Print(a);}
\end{center}

The corresponding parse tree is generated automatically as a PDF in the \texttt{more/} folder
(see Figure~\ref{fig:TooMuchSpaceTree}).

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{TooMuchSpace.pdf}
    \caption{Parse tree generated for the test file \texttt{TooMuchSpace.ycc}.}
    \label{fig:TooMuchSpaceTree}
\end{figure}


\subsection{Other example Test: \texttt{WhileOne.ycc}}

During testing, the file \texttt{WhileOne.ycc} produced the following error:

\begin{quote}
\texttt{Syntax error at line 6, column 10: While parsing <RelTail>: unexpected token RBRACK('\}')}

\end{quote}

This behaviour is correct given the final grammar.  
In our language, the condition of a \texttt{While}-statement must be a well-formed
logical or relational expression. According to the grammar:

\[
\langle While \rangle \rightarrow 
\texttt{While \{ } \langle Cond \rangle \texttt{ \} Do } 
\langle Code \rangle \texttt{ End}
\]

\[
\langle Cond \rangle \rightarrow 
\langle Imp \rangle
\]

\[
\langle Imp \rangle \rightarrow 
\langle AtomImp \rangle\, \langle Imp' \rangle
\]

\[
\langle AtomImp \rangle \rightarrow 
\lvert \langle Cond \rangle \rvert
\]

\[
\langle AtomImp \rangle \rightarrow 
\langle Rel \rangle
\]

\[
\langle Rel \rangle \rightarrow 
\langle ExprArith \rangle\, \langle RelTail \rangle
\]

\[
\langle RelTail \rangle \rightarrow 
\langle Comp \rangle\, \langle ExprArith \rangle
\]


A condition therefore cannot consist solely of a numeric literal such as \texttt{1}.  
The input fragment

\[
\texttt{While \{1\} Do}
\]

is parsed as a relational expression; after reading the arithmetic expression
\texttt{1}, the parser expects a comparison operator (\texttt{==}, \texttt{<=}, or \texttt{<})
in order to complete the production for $\langle RelTail \rangle$.
Encountering the closing brace \texttt{\}} instead leads to the reported syntax error.

This confirms that the parser behaves as specified by the grammar:  
a standalone number is not a valid condition in this language.
To express an unconditional loop, one must use a valid relational or logical expression,
for example \texttt{\{1 == 1\}}.


\subsection{Discussion of Correctness}

This test validates several essential aspects of the LL(1) parser:

\paragraph{Correct handling of whitespace.}
Whitespace is ignored by the lexical analyzer, ensuring that parsing is unaffected by formatting irregularities.

\paragraph{Correct rule selection using FIRST and FOLLOW.}
After reading a semicolon, the parser chooses between rule~2 and rule~3 based solely on the lookahead.
Since the lookahead before \texttt{End} belongs to FOLLOW(\texttt{Code}), the epsilon rule~3 is correctly selected.

\paragraph{Correct behaviour of right recursion.}
The grammar uses right recursion for \texttt{Code}, and the resulting tree matches this structure precisely:
\texttt{Instruction ; Code} is expanded until \texttt{Code → ε}.

\paragraph{Structural compliance with the final grammar.}
Every node in the tree corresponds exactly to one of the 40 productions defined in the final grammar,
demonstrating that the parser respects the formal specification.

\subsection{Summary of Test Results}

All provided test files were executed successfully using both \texttt{make runTest} and \texttt{make runWTTest}.  
The parser correctly identified syntax errors, handled nested constructs, expanded epsilon-productions appropriately, and produced well-formed parse trees for all valid programs.  
These results confirm the functional correctness of our LL(1) parser and its conformity to the final grammar.

\section{Conclusion}

This project led to the design and implementation of a complete LL(1) parsing
system, starting from an initially ambiguous grammar and ending with a functional
recursive–descent parser capable of handling the yaLcc language.  
Through the successive transformations applied to the grammar—removing ambiguity,
eliminating left recursion, and applying factorization—we obtained a form that
can be parsed deterministically with a single lookahead symbol.

The implementation reflects the structure of this transformed grammar: each
non-terminal is associated with a dedicated parsing routine, and FIRST/FOLLOW
information guides the selection of productions. The resulting leftmost
derivation and parse tree confirm, step by step, how the program is expanded
according to the grammar.

The extensive test suite, which includes simple programs, nested constructs,
implication chains, loops, whitespace variations, comment handling, and a range
of error cases, demonstrated that the parser behaves predictably and that the
grammar supports deterministic LL(1) parsing.




\section*{References}

\begin{itemize}
\item G.~Geeraerts, A.~Leponce, \emph{INFO403 — Language Theory and Compiling}, Université Libre de Bruxelles, 2025.
    \item Aho, Lam, Sethi, Ullman — \emph{Compilers: Principles, Techniques, and Tools}
          (2nd Edition), Addison-Wesley, 2006.
    \item JFlex Official Documentation — \url{https://www.jflex.de/}
    \item Oracle Java SE Documentation — \url{https://docs.oracle.com/javase/}
    \item ANTLR Documentation — Concepts of grammar transformations and LL parsing, \url{https://www.antlr.org/}
\end{itemize}

\end{document}
